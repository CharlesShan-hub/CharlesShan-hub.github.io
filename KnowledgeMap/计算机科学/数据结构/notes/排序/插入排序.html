<!doctype html>
<html style='font-size:22px !important'>
<head>
<link rel="shortcut icon" type="image/x-icon" href="https://charlesshan.top/resources/favicon.ico?">
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<title>PKM - Personal Knowledge Map</title>
</head>
<body class='typora-export'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='插入排序'><span>插入排序</span></h1><p><span>2022.09.19</span></p><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n0"><a class="md-toc-inner" style="" href="#插入排序">插入排序</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n4"><a class="md-toc-inner" style="" href="#直接插入排序">直接插入排序</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n16"><a class="md-toc-inner" style="" href="#折半插入排序">折半插入排序</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n34"><a class="md-toc-inner" style="" href="#希尔排序">希尔排序</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n50"><a class="md-toc-inner" style="" href="#例题">例题</a></span></p></div><h2 id='直接插入排序'><span>直接插入排序</span></h2><p><span>从头到尾一个个排序。第i+1轮判断num[i]的大小，num[0]到num[i-1]已经排好序，要将num[i]插入到num[0]至num[i-1]中。</span></p><p><span>空间复杂度：O(1)</span></p><p><span>时间复杂度：最好O(n)，最坏O(n^2)</span></p><p><span>稳定性：稳定</span></p><p><span>适用性：顺序存储的线性表</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="C"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 30.890625px; left: 22.890625px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">InserSort</span>(<span class="cm-variable">ElemType</span> <span class="cm-variable">A</span>[], <span class="cm-variable-3">int</span> <span class="cm-variable">n</span>){</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-keyword">for</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">i</span><span class="cm-operator">=</span><span class="cm-number">2</span>;<span class="cm-variable">i</span><span class="cm-operator">&lt;=</span><span class="cm-variable">n</span>;<span class="cm-variable">i</span><span class="cm-operator">++</span>) <span class="cm-comment">// 依次将A[2]～A[n]插入前面已经排序序列</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">A</span>[<span class="cm-variable">i</span>]<span class="cm-operator">&lt;</span><span class="cm-variable">A</span>[<span class="cm-variable">i</span><span class="cm-operator">-</span><span class="cm-number">1</span>]){ &nbsp; &nbsp;<span class="cm-comment">// 发现逆序，需要将该元素插入到前边</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-variable">A</span>[<span class="cm-number">0</span>]<span class="cm-operator">=</span><span class="cm-variable">A</span>[<span class="cm-variable">i</span>]; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 将该元素放到哨兵位置</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">for</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">j</span><span class="cm-operator">=</span><span class="cm-variable">i</span><span class="cm-operator">-</span><span class="cm-number">1</span>;<span class="cm-variable">A</span>[<span class="cm-number">0</span>]<span class="cm-operator">&lt;</span><span class="cm-variable">A</span>[<span class="cm-variable">j</span>];<span class="cm-variable">j</span><span class="cm-operator">--</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">A</span>[<span class="cm-variable">j</span><span class="cm-operator">+</span><span class="cm-number">1</span>]<span class="cm-operator">=</span><span class="cm-variable">A</span>[<span class="cm-variable">j</span>]; &nbsp; &nbsp;<span class="cm-comment">// 从后向前依次向后移动</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-variable">A</span>[<span class="cm-variable">j</span><span class="cm-operator">+</span><span class="cm-number">1</span>]<span class="cm-operator">=</span><span class="cm-variable">A</span>[<span class="cm-number">0</span>]; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 元素复制到插入位置</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 308px;"></div><div class="CodeMirror-gutters" style="display: none; height: 308px;"></div></div></div></pre><h2 id='折半插入排序'><span>折半插入排序</span></h2><p><span>直接插入中首先从后向前移动元素，实际就是在找位置。这一步可以优化成先用折半查找找到位置，然后集体移动元素。</span></p><p><span>空间复杂度：O(1)</span></p><p><span>时间复杂度：最好O(n)，最坏O(max{nlog2 n, n^2})=O(n^2)</span></p><p><span>稳定性：稳定</span></p><p><span>适用性：顺序存储的线性表</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="C" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 30.890625px; left: 22.890625px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">InserSort</span>(<span class="cm-variable">ElemType</span> <span class="cm-variable">A</span>[], <span class="cm-variable-3">int</span> <span class="cm-variable">n</span>){</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">low</span>,<span class="cm-variable">mid</span>,<span class="cm-variable">high</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-keyword">for</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">i</span><span class="cm-operator">=</span><span class="cm-number">2</span>;<span class="cm-variable">i</span><span class="cm-operator">&lt;=</span><span class="cm-variable">n</span>;<span class="cm-variable">i</span><span class="cm-operator">++</span>){ <span class="cm-comment">// 依次将A[2]到A[n]插入前面的已排序序列</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">A</span>[<span class="cm-number">0</span>]<span class="cm-operator">=</span><span class="cm-variable">A</span>[<span class="cm-variable">i</span>]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">// 将A[i]暂存到A[0]</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// Step 1. 折半查找</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">low</span><span class="cm-operator">=</span><span class="cm-number">1</span>;<span class="cm-variable">high</span><span class="cm-operator">=</span><span class="cm-variable">i</span><span class="cm-operator">-</span><span class="cm-number">1</span>; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 折半查找范围</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span>(<span class="cm-variable">low</span><span class="cm-operator">&lt;=</span><span class="cm-variable">high</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-variable">mid</span> <span class="cm-operator">=</span> (<span class="cm-variable">low</span><span class="cm-operator">+</span><span class="cm-variable">high</span>)<span class="cm-operator">/</span><span class="cm-number">2</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">A</span>[<span class="cm-variable">mid</span>]<span class="cm-operator">&gt;</span><span class="cm-variable">A</span>[<span class="cm-number">0</span>]) <span class="cm-variable">high</span><span class="cm-operator">=</span><span class="cm-variable">mid</span><span class="cm-operator">-</span><span class="cm-number">1</span>; <span class="cm-comment">// 取左一半</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-keyword">else</span> <span class="cm-variable">low</span><span class="cm-operator">=</span><span class="cm-variable">mid</span><span class="cm-operator">+</span><span class="cm-number">1</span>; &nbsp; <span class="cm-comment">// 取右一半</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// Step 2. 统一后移</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">for</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">j</span><span class="cm-operator">=</span><span class="cm-variable">i</span><span class="cm-operator">-</span><span class="cm-number">1</span>;<span class="cm-variable">j</span><span class="cm-operator">&gt;=</span><span class="cm-variable">high</span><span class="cm-operator">+</span><span class="cm-number">1</span>;<span class="cm-variable">j</span><span class="cm-operator">--</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;<span class="cm-variable">A</span>[<span class="cm-variable">j</span><span class="cm-operator">+</span><span class="cm-number">1</span>]<span class="cm-operator">=</span><span class="cm-variable">A</span>[<span class="cm-variable">j</span>];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">A</span>[<span class="cm-variable">high</span><span class="cm-operator">+</span><span class="cm-number">1</span>]<span class="cm-operator">=</span><span class="cm-variable">A</span>[<span class="cm-number">0</span>];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom-width: 0px; border-bottom-style: solid; border-bottom-color: transparent; top: 504px;"></div><div class="CodeMirror-gutters" style="display: none; height: 504px;"></div></div></div></pre><h2 id='希尔排序'><span>希尔排序</span></h2><p><span>将一个表分成n个字表，每个字表内进行</span><strong><span>直接插入排序</span></strong><span>。然后再对整体进行</span><strong><span>直接插入排序</span></strong><span>。</span></p><p><img src="resources/希尔排序.png" referrerpolicy="no-referrer" alt="image-20220919180848808"></p><p><span>空间复杂度：O(1)</span></p><p><span>时间复杂度：特定范围n：O(n^1.3)，最坏O(n^2)</span></p><p><span>稳定性：不稳定</span></p><p><span>适用性：顺序存储的线性表</span></p><h2 id='例题'><span>例题</span></h2><ol><li><p><span>对5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（ ）。</span>
<span>A. 8</span>
<span>B. 10</span>
<span>C. 15</span>
<span>D. 25</span></p><p><span>【答案】：1+2+3+4=10，B</span></p></li></ol><ol start='02' ><li><p><span>在待排序的元素序列基本有序的前提下，效率最高的排序方法是（ ）</span>
<span>A. 直接插入排序 </span>
<span>B. 简单选择排序</span>
<span>C. 快速排序</span>
<span>D. 归并排序</span></p><p><span>【答案】：A</span></p></li><li><p><span>对有n个元素的顺序表来用直接插入排序算法进行排序，在最坏情况下所需的比较次数是（ ）；在最好情況下所需的比较次数是（ ）。</span>
<span>A. n-1</span>
<span>B. n+1</span>
<span>C. n/2</span>
<span>D. n(n-1)/2</span></p><p><span>【答案】：DA</span></p></li><li><p><span>数据序列{8,10,13,4,6,7,22,2,33只能是（）两趟排序后的结果。</span>
<span>A. 简单选择排序 B.起泡排序</span>
<span>C．直接插入排序 D.堆排序</span></p><p><span>【答案】：C</span></p></li><li><p><span>用直接插入排序算法对下列4个表进行（从小到大）排序，比较次数最少的是(）</span>
<span>A. 94,32,40,90,80,46,21,69</span>
<span>B. 21, 32, 46, 40, 80, 69, 90, 94</span>
<span>C. 32,40,21, 46,69,94,90,80</span>
<span>D. 90,69,80,46,21, 32,94,40</span></p><p><span>【答案】：B</span></p></li><li><p><span>在下列算法中，（）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上。</span>
<span>A.堆排序</span>
<span>B.冒泡排序</span>
<span>C．直接插入排序 </span>
<span>D.快速排序</span></p><p><span>【答案】：C</span></p></li><li><p><span>希尔排序属于（）.</span>
<span>A. 插入排序</span>
<span>B.交换排序</span>
<span>C.选择排序</span>
<span>D.归并排序</span></p><p><span>【答案】：A</span></p></li><li><p><span>对序列{15,9,7,8,20,-1,4}用希尔排序方法排序，经一趟后序列变为{15,-1,4,8,20,9,7}，则该次采用的增量是(）。</span>
<span>A. 1</span>
<span>B. 4</span>
<span>C. 3</span>
<span>D. 2</span></p><p><span>【答案】：D -&gt; B</span></p></li><li><p><span>若对于第9题中的序列，经一趟排序后序列变成{9,15,7,8,20,-1,4}，则来用的是下列的（ ）.</span>
<span>A. 选择排序</span>
<span>B.快速排序</span>
<span>C.直接插入排序 </span>
<span>D.冒泡排序</span></p><p><span>【答案】：C</span></p></li><li><p><span>对序列{98,36,-9,0,47,23,1,8，10,7}来用希尔排序，下列序列（ ）是增量为4的一趟排序结果。</span>
<span>A. (10, 7, -9, 0, 47, 23, 1, 8, 98, 36}</span>
<span>B. (-9, 0, 36, 98, 1, 8, 23, 47, 7, 10}</span>
<span>C. {36,98,-9,0,23,47,1,8,7,10}</span>
<span>D.以上都不对</span></p><p><span>【答案】：A</span></p></li><li><p><span>折半插入排序算法的时问复杂度为（ ）。</span></p><p><span>A.O(n)</span>
<span>B. O(nlog_2 n)</span>
<span>C. O(n^2)</span>
<span>D.O(n^3)</span></p><p><span>【答案】：C</span></p></li><li><p><span>有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，（）算法不会出现此种情况。</span>
<span>A. 希尔排序</span>
<span>B.堆排序</span>
<span>C.冒泡排序</span>
<span>D.快速排序</span></p><p><span>【答案】：A</span></p></li><li><p><span>以下排序算法中，不稳定的是(）。</span>
<span>A.冒泡排序</span>
<span>B.直接插入排序</span>
<span>C.希尔排序</span>
<span>D.归并排序</span></p><p><span>【答案】：C</span></p></li><li><p><span>以下排序算法中，稳定的是(）。</span>
<span>A. 快速排序</span>
<span>B. 堆排序</span>
<span>C.直校插入排序</span>
<span>D.简单选择排序</span></p><p><span>【答案】：C</span></p></li><li><p><span>【2009 统考真题】若数据元素序列{11,12，13,7,8,9,23,4,5}是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是(）。</span></p><p><span>A.冒泡排序</span>
<span>B. 插入排序</span>
<span>C.选择排序</span>
<span>D.2路归并排序</span></p><p><span>【答案】：B</span></p></li><li><p><span>【2012统考真题】对同一待排序序列分別进行折半插入排序和直接插入排序，两者之问可能的不同之处是(）。</span>
<span>A. 排序的总趟数</span>
<span>B.元素的移动次数</span>
<span>C.使用辅助空问的数量</span>
<span>D.元素之间的比较次数</span></p><p><span>【答案】：D</span></p></li><li><p><span>【2014 统考其题】用希尔排序方法对一个数据序列进行排序时，若第1趟排序结果为9,1,4,13,7,8,20,23,15，则该道排序采用的增量（问隔）可能是（）</span>
<span>A. 2</span>
<span>B.3</span>
<span>C.4</span>
<span>D. 5</span></p><p><span>【答案】：B</span></p></li><li><p><span>【2015 统考真题】希尔排序的组内排序来用的是（）。</span>
<span>A．直接插入排序 B.折半插入排序 C.快速排序D.归并排序</span></p><p><span>【答案】：A</span></p></li><li><p><span>【2018 统考真题】对初始数据序列(8,3,9,11,2,1,4,7,5,10,6)进行希尔排序。若第一趟排序结果为(1,3,7,5,2,6,4,9,11,10,8), 第二趟排序结果为(1,2,5,4,3,7,5,8,11,10,9}，則两道排序采用的增量（问隔）依次是(）。</span>
<span>A. 3,1</span>
<span>B. 3,2</span>
<span>C. 5,2</span>
<span>D. 5,3</span></p><p><span>【答案】：D</span></p></li></ol><p>&nbsp;</p></div></div>
</body>
</html>